import praw
import prawcore.exceptions
import requests
import time
from datetime import datetime
import numpy as np
from PIL import Image
import imagehash
import cv2
import threading

# Define the threshold for maximum API requests per minute
MAX_REQUESTS_PER_MINUTE = 100
api_requests_count = 0
minute_start_time = time.time()

# Initialize Reddit once and reuse globally
reddit = praw.Reddit(
    client_id='jl-I3OHYH2_VZMC1feoJMQ',
    client_secret='TCOIQBXqIskjWEbdH9i5lvoFavAJ1A',
    username='PokeLeakBot3',
    password='testbot1',
    user_agent='testbot'
)
subreddit = reddit.subreddit("PokeLeaks")

def make_api_request():
    global api_requests_count, minute_start_time
    current_time = time.time()
    if current_time - minute_start_time >= 60:
        minute_start_time = current_time
        api_requests_count = 0
    if api_requests_count >= MAX_REQUESTS_PER_MINUTE:
        throttle_duration = 60 - (current_time - minute_start_time) + 5
        print(f"Throttling for {throttle_duration} seconds...")
        time.sleep(throttle_duration)
    api_requests_count += 1

def handle_exception(e):
    if isinstance(e, prawcore.exceptions.ResponseException) and e.response.status_code == 429:
        print("Rate limited by Reddit API. Ignoring error.")
    else:
        print(f"Exception encountered: {str(e)}")

def monitor_reported_posts():
    try:
        while True:
            make_api_request()
            for post in subreddit.mod.reports():
                make_api_request()
                if post.approved:
                    post.mod.approve()
                    print(f"Post {post.id} has been approved again")
    except Exception as e:
        handle_exception(e)

def handle_modqueue_items():
    timers = {}
    try:
        while True:
            make_api_request()
            for item in subreddit.mod.modqueue():
                make_api_request()
                if item.num_reports == 1 and item.id not in timers:
                    timers[item.id] = time.time()
                    print(f"Starting timer for post {item.id}...")
                if item.id in timers:
                    start_time = timers[item.id]
                    if time.time() - start_time >= 3600:
                        try:
                            make_api_request()
                            item.mod.approve()
                            print(f"Approved post {item.id} with one report")
                            del timers[item.id]
                        except prawcore.exceptions.ServerError as e:
                            handle_exception(e)
    except Exception as e:
        handle_exception(e)

def handle_spoiler_status():
    previous_spoiler_status = {}
    while True:
        make_api_request()
        for submission in subreddit.new():
            make_api_request()
            if submission.id not in previous_spoiler_status:
                previous_spoiler_status[submission.id] = submission.spoiler
                continue
            if previous_spoiler_status[submission.id] != submission.spoiler:
                is_moderator = submission.author in subreddit.moderator()
                if not submission.spoiler and not is_moderator:
                    try:
                        make_api_request()
                        print(f'Post {submission.id} unmarked as spoiler by non-mod. Re-spoiling.')
                        submission.mod.spoiler()
                    except prawcore.exceptions.ServerError as e:
                        handle_exception(e)
                previous_spoiler_status[submission.id] = submission.spoiler

def handle_user_reports_and_removal():
    thresholds = {
        'Comments complaining about Riddler Khu will be removed. Ignore the post if you are going to complain': 1,
        'No insults or harassment of other subreddit members in the comments': 1,
        'No asking about or sharing of XCI or NSP files': 1
    }
    try:
        while True:
            make_api_request()
            for comment in subreddit.mod.modqueue(limit=100):
                make_api_request()
                if isinstance(comment, praw.models.Comment) and comment.user_reports:
                    reason, count = comment.user_reports[0]
                    if reason in thresholds and count >= thresholds[reason]:
                        try:
                            make_api_request()
                            comment.mod.remove()
                            print(f'Removed comment due to {count} reports: {reason}')
                        except prawcore.exceptions.ServerError as e:
                            handle_exception(e)
    except Exception as e:
        handle_exception(e)

def handle_submissions_based_on_user_reports():
    thresholds = {'This is misinformation': 1, 'This is spam': 1}
    while True:
        make_api_request()
        for post in subreddit.mod.modqueue(limit=100):
            make_api_request()
            if isinstance(post, praw.models.Submission) and post.user_reports:
                reason, count = post.user_reports[0]
                if reason in thresholds and count >= thresholds[reason]:
                    try:
                        make_api_request()
                        post.mod.approve()
                        print(f'Post \"{post.title}\" approved due to {count} reports: {reason}')
                    except prawcore.exceptions.ServerError as e:
                        handle_exception(e)

def handle_posts_based_on_removal():
    thresholds = {
        'Posts must be about leaks, riddles, news, and rumours about PokÃ©mon content': 2,
        'Post must not contain any profanities, vulgarity, sexual content, slurs, be appropriate in nature': 2,
        'No reposting of posts already up on the subreddit': 1,
        'No memes allowed': 2,
        'No joke submissions or shitposts': 2,
        'No Self Advertisements/Promotion': 2,
        'No Fan art': 2,
        'Theories, Questions, Speculations must be commented in the Theory/Speculation/Question Megathread': 2,
        'Posts with spoilers must have required spoiler flair, indicate spoiler alert in title, and be vague': 3,
        'Retarded': 1
    }
    while True:
        make_api_request()
        for post in subreddit.mod.modqueue(limit=100):
            make_api_request()
            if isinstance(post, praw.models.Submission) and post.user_reports:
                reason, count = post.user_reports[0]
                if reason in thresholds and count >= thresholds[reason]:
                    try:
                        make_api_request()
                        post.mod.remove()
                        print(f'Removed post due to {count} reports: {reason}')
                    except prawcore.exceptions.ServerError as e:
                        handle_exception(e)

def handle_comments_based_on_approval():
    thresholds = {'This is misinformation': 1, 'This is spam': 1}
    while True:
        make_api_request()
        for comment in subreddit.mod.modqueue(limit=100):
            make_api_request()
            if isinstance(comment, praw.models.Comment) and comment.user_reports:
                reason, count = comment.user_reports[0]
                if reason in thresholds and count >= thresholds[reason]:
                    try:
                        make_api_request()
                        comment.mod.approve()
                        print(f'Comment approved due to {count} reports: {reason}')
                    except prawcore.exceptions.ServerError as e:
                        handle_exception(e)

def run_pokemon_duplicate_bot():
    image_hashes = {}
    moderator_removed_hashes = set()
    processed_modqueue_submissions = set()
    current_time = int(time.time())

    def post_comment(submission, original_post_author, original_post_title, original_post_link, original_post_date):
        max_retries = 3
        for _ in range(max_retries):
            try:
                make_api_request()
                comment = submission.reply(
                    ">| Title | Date and Time |\n"
                    ">|:---:|:---:|\n"
                    ">| [{}]({}) | {} |\n\n"
                    ">[Link to Original Post]({})".format(
                        original_post_title, original_post_link,
                        original_post_date, original_post_link)
                )
                make_api_request()
                comment.mod.distinguish(sticky=True)
                print("Duplicate removed and comment posted: ", submission.url)
                return True
            except Exception as e:
                handle_exception(e)
                time.sleep(1)
        return False

    def check_removed_original_posts():
        while True:
            for hash_value, (submission_id, creation_time) in list(image_hashes.items()):
                try:
                    make_api_request()
                    original_submission = reddit.submission(id=submission_id)
                    if original_submission.banned_by is not None or original_submission.author is None:
                        moderator_removed_hashes.add(hash_value)
                        del image_hashes[hash_value]
                except Exception as e:
                    handle_exception(e)
            time.sleep(30)

    threading.Thread(target=check_removed_original_posts, daemon=True).start()

    def process_submission(submission):
        try:
            if submission.url.endswith(('jpg', 'jpeg', 'png', 'gif')):
                image_data = requests.get(submission.url).content
                img = np.asarray(bytearray(image_data), dtype=np.uint8)
                img = cv2.imdecode(img, cv2.IMREAD_COLOR)
                gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                hash_value = str(imagehash.phash(Image.fromarray(gray)))

                if hash_value in moderator_removed_hashes and not submission.approved:
                    submission.mod.remove()
                    print("Repost of a mod-removed image removed: ", submission.url)
                    return

                if hash_value in image_hashes:
                    original_id, original_time = image_hashes[hash_value]
                    original_submission = reddit.submission(id=original_id)
                    if submission.author != original_submission.author and submission.created_utc > original_time:
                        if not submission.approved:
                            submission.mod.remove()
                            print("Duplicate removed: ", submission.url)
                            post_comment(
                                submission,
                                original_submission.author.name,
                                original_submission.title,
                                f"https://www.reddit.com{original_submission.permalink}",
                                datetime.utcfromtimestamp(original_submission.created_utc).strftime('%Y-%m-%d %H:%M:%S')
                            )
                    else:
                        image_hashes[hash_value] = (submission.id, submission.created_utc)
                else:
                    image_hashes[hash_value] = (submission.id, submission.created_utc)
        except Exception as e:
            handle_exception(e)

    try:
        for submission in subreddit.new(limit=100):
            make_api_request()
            process_submission(submission)
    except Exception as e:
        handle_exception(e)

    while True:
        try:
            for submission in subreddit.new():
                make_api_request()
                if submission.created_utc > current_time:
                    process_submission(submission)
                    current_time = int(time.time())

            modqueue_submissions = sorted(
                subreddit.mod.modqueue(only='submission', limit=None),
                key=lambda x: x.created_utc
            )

            for submission in modqueue_submissions:
                make_api_request()
                if isinstance(submission, praw.models.Submission):
                    if submission.num_reports > 0:
                        print("Skipping reported image: ", submission.url)
                        image_hashes = {k: v for k, v in image_hashes.items() if v[0] != submission.id}
                        continue
                    process_submission(submission)
        except Exception as e:
            handle_exception(e)

def monitor_threads(threads):
    while True:
        for thread_name, thread in threads.items():
            if not thread.is_alive():
                print(f"Thread {thread_name} has stopped. Restarting...")
                new_thread = threading.Thread(target=thread._target)
                threads[thread_name] = new_thread
                new_thread.start()
        time.sleep(10)

if __name__ == "__main__":
    threads = {
        'modqueue_thread': threading.Thread(target=handle_modqueue_items),
        'reported_posts_thread': threading.Thread(target=monitor_reported_posts),
        'spoiler_status_thread': threading.Thread(target=handle_spoiler_status),
        'user_reports_removal_thread': threading.Thread(target=handle_user_reports_and_removal),
        'submissions_based_on_user_reports_thread': threading.Thread(target=handle_submissions_based_on_user_reports),
        'posts_based_on_removal_thread': threading.Thread(target=handle_posts_based_on_removal),
        'comments_based_on_approval_thread': threading.Thread(target=handle_comments_based_on_approval),
        'run_pokemon_duplicate_bot_thread': threading.Thread(target=run_pokemon_duplicate_bot),
    }

    for thread in threads.values():
        thread.start()

    monitor_threads(threads)
